高并发编程
1、同步和异步的区别和联系
    所谓同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其它的命令。
    异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。
    同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行(死心眼)。
    异步在一定程度上可以看做是多线程的(废话，一个线程怎么叫异步)，请求一个方法后，就不管了，继续执行其他的方法。
    PS：
        脏数据：
        　　脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这
        个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据(Dirty Data)，依据脏数据所做的操作可能是不正确的。
        不可重复读：
        　　不可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由
        于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读

2、如何处理并发和同步：主要是通过锁机制
    锁机制有两个层面
        A：一种是代码层次上的，如java中的同步锁，典型的就是同步关键字synchronized
        B：另外一种是数据库层次上的，比较典型的就是悲观锁和乐观锁。
        ->悲观锁(Pessimistic Locking)--[高并发系统耗费资源过大，不适应]:
           悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自 外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。
           悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。
                一个典型的倚赖数据库的悲观锁调用：
                    select * from account where name=”Erica” for update;(必须在事务中)
                    这条 sql 语句锁定了 account 表中所有符合检索条件（ name=”Erica” ）的记录。
                    本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。
        ->乐观锁(Optimistic Locking):
                   相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依 靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之
          而来的就是数据库 性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数
          据的基础上进 行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过 程中（从操作员读出数据、开始修改直至提交修改结果的全
          过程，甚至还包括操作 员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几 百上千个并发，这样的情况将导致怎样的后果。 乐
          观锁机制在一定程度上解决了这个问题。
                   乐观锁，大多是基于数据版本   Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通
          过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据
          库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

常见的提高高并发下访问的效率的手段
      首先要了解高并发的的瓶颈在哪里？
         1、可能是服务器网络带宽不够
         2.可能web线程连接数不够
         3.可能数据库连接查询上不去。
     根据不同的情况，解决思路也不同。
        像第一种情况可以增加网络带宽，DNS域名解析分发多台服务器。
        负载均衡，前置代理服务器nginx、apache等等
        数据库查询优化，读写分离，分表等等
   最后复制一些在高并发下面需要常常需要处理的内容:
        尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。
        用jprofiler等工具找出性能瓶颈，减少额外的开销。
        优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。
        优化数据库结构，多做索引，提高查询效率。
        统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。
        能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。
        解决以上问题后，使用服务器集群来解决单台的瓶颈问题。

















