进程和线程：
    进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。
    多个线程是共同占有所属进程的资源和地址空间的。
在java中，一个应用程序对应着一个jvm实例(jvm进程)。
java采用单线程编程模型，即在程序中没有主动创建线程的话，只会创建一个线程--主线程。但并不表示jvm中只有一个线程，jvm实例在创建的时候，同时会创建很多
    其他的线程(如gc等)

同步：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；
异步：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。
阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；
非阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。
阻塞IO：如果数据没有就绪，则会一直在那等待，直到数据就绪；
非阻塞IO：如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作
同步IO： 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；
异步IO： 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。

线程中方法介绍：
    start方法：start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。
    run方法：run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。
    sleep方法：sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。（不会释放锁）
    yield方法：调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。
            　　注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。
    join方法：调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的事件。
    interrupt方法：单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。

线程安全：多个线程同时访问一个资源[临界资源、共享资源]时，会导致程序运行结果并不是想看到的结果。
    --解决方案：即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。
               在Java中，提供了两种方式来实现同步互斥访问：synchronized和Lock。

    synchronized修饰方法注意点：
        1、当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。、
        2、当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的
        注意：每个类也会有一个锁，它可以用来控制对static数据成员的并发访问。
            并且如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。

    synchronized修饰的释放锁：
        获取锁的线程执行完了该代码块，然后线程释放对锁的占有；
        线程执行发生异常，此时JVM会让线程自动释放锁。

    Lock：
        1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；
        2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。
    Lock方法介绍：
        lock()：平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。
            注：由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。

可重入锁：如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的
    分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会
    调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。
        class MyClass {
            public synchronized void method1() {
                method2();
            }
            public synchronized void method2() {
            }
        }
可中断锁：顾名思义，就是可以相应中断的锁。
    在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。
公平锁：公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。
    在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。
    而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。
        ReentrantLock lock = new ReentrantLock(true);true--表示公平锁，false--表示非公平锁；默认无参非公平锁
读写锁：读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。
    　　正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。
    　　ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。
    　　可以通过readLock()获取读锁，通过writeLock()获取写锁。

并发编程的三个问题：
    原子性
    可见性
        对于可见性，Java提供了volatile关键字来保证可见性。
    有序性
        在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile：
    当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
    而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

volatile关键字的两层语义
    1、保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
    2、禁止进行指令重排序。

ThreadLocal：线程本地变量--案例见example.ConnectionManager
    这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。
    那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。
    但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。

同步容器
    1）Vector、Stack、HashTable
        Vector：Vector实现了List接口，Vector实际上就是一个数组，和ArrayList类似，但是Vector中的方法都是synchronized方法，即进行了同步措施。
        Stack：它的方法也用synchronized进行了同步，它实际上是继承于Vector类。
        HashTable：实现了Map接口，它和HashMap很相似，但是HashTable进行了同步处理，而HashMap没有。
    2）Collections类中提供的静态工厂方法创建的类
        Collections类是一个工具提供类，注意，它和Collection不同，Collection是一个顶层的接口。
        在Collections类中提供了大量的方法，比如对集合或者容器进行排序、查找等操作。最重要的是，在它里面提供了几个静态工厂方法来创建同步容器类
            Connections.synchronized*

ConcurrentModificationException
    对Vector、ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常

